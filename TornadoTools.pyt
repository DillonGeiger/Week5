# -*- coding: utf-8 -*-import arcpyclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "TornadoTools"        self.alias = "TornadoTools"        # List of tool classes associated with this toolbox        self.tools = [TornadoSelection, TornadoBuffer, CountyTornado,PathSelection]class TornadoSelection(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "TornadoSelection"        self.description = "a selection based off user input date range, state, and magnitute"        self.canRunInBackground = False    def getParameterInfo(self):                in_feature = arcpy.Parameter(name = 'in_feature', displayName = 'in file', datatype = 'DEFeatureClass', parameterType = 'optional', direction = 'input')        start_date = arcpy.Parameter(name = 'start_date', displayName = 'from Date (yyyy-mm-dd)', datatype = 'GPString', parameterType = 'optional', direction = 'input')        end_date = arcpy.Parameter(name = 'end_date', displayName = 'to Date (yyyy-mm-dd)', datatype = 'GPString', parameterType = 'optional', direction = 'input')        state = arcpy.Parameter(name = 'state', displayName = 'state', datatype = 'GPSQLExpression', parameterType = 'optional', direction = 'input')        state.parameterDependencies = [in_feature.name]        magnitude = arcpy.Parameter(name = 'magnitude', displayName = 'EF Scale (0-5)', datatype = 'GPLong', parameterType = 'optional', direction = 'input')        magnitude.filter.type = 'Range'        magnitude.filter.list = [0,5]                parameters = [in_feature, start_date, end_date, state, magnitude]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        wksp = arcpy.env.workspace = "C:\\Dillon Geiger\\GIS_4085_Python_II\\week5_pythonII\\week5_pythonII.gdb"        in_feature = parameters[0].valueAsText        start_date = parameters[1].valueAsText        end_date = parameters[2].valueAsText        state = parameters[3].valueAsText        magnitude = parameters[4].valueAsText        #made date selection *within range*        date_SQL = """date BETWEEN '{}' AND '{}'""".format(start_date, end_date)        datelyr = arcpy.management.SelectLayerByAttribute(in_feature, "NEW_SELECTION", date_SQL)        datecnt = arcpy.management.GetCount(datelyr)        arcpy.AddMessage(datecnt)        arcpy.management.CopyFeatures(datelyr, 'date_test')        #of the selection make an aditional selection WITHIN a state.        stlyr = arcpy.management.SelectLayerByAttribute(datelyr, "SUBSET_SELECTION", state)        stcnt = arcpy.management.GetCount(stlyr)        arcpy.AddMessage(stcnt)        arcpy.management.CopyFeatures(stlyr, 'state_test')        #with the results make a final selection         mag_SQL = """mag = {}""".format(magnitude)        maglyr = arcpy.management.SelectLayerByAttribute(stlyr, "SUBSET_SELECTION", mag_SQL)        magcnt = arcpy.management.GetCount(maglyr)        arcpy.AddMessage(magcnt)        arcpy.management.CopyFeatures(maglyr, 'mag_test')    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return    ######################################################class TornadoBuffer(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "TornadoBuffer"        self.description = "a user selection buffer range around point data with a defined output"        self.canRunInBackground = False    def getParameterInfo(self):        in_feature = arcpy.Parameter(name = 'in_feature', displayName = 'in file', datatype = 'DEFeatureClass', parameterType = 'optional', direction = 'input')        distance = arcpy.Parameter(name = 'distance', displayName = 'buffer distance', datatype = 'GPString', parameterType = 'optional', direction = 'input')        output = arcpy.Parameter(name = 'output', displayName = 'output name', datatype = 'GPString', parameterType = 'optional', direction = 'output')        parameters = [in_feature, distance, output]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        wksp = arcpy.env.workspace = "C:\\Dillon Geiger\\GIS_4085_Python_II\\week5_pythonII\\week5_pythonII.gdb"        in_feature = parameters[0].valueAsText        distance = parameters[1].valueAsText        output = parameters[2].valueAsText                tornado_buff = arcpy.analysis.Buffer(in_feature, output, distance)        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return######################################################class CountyTornado(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "CountyTornado"        self.description = "a user selection of county, state, and year. Populates new fc with total injuries, fatalities and cost (crop loss + property loss) for the selected year."        self.canRunInBackground = False    def getParameterInfo(self):        in_boundary = arcpy.Parameter(name = 'in_boundry', displayName = 'boundary file', datatype = 'DEFeatureClass', parameterType = 'required', direction = 'input')        in_tornado = arcpy.Parameter(name = 'in_tornado', displayName = 'tornado data', datatype = 'DEFeatureClass', parameterType = 'required', direction = 'input')        state = arcpy.Parameter(name = 'state', displayName = 'state abbreviation', datatype = 'GPString', parameterType = 'required', direction = 'input')        county = arcpy.Parameter(name = 'county', displayName = 'county name', datatype = 'GPString', parameterType = 'required', direction = 'input')        county.parameterDependencies = [in_boundary.name]        year = arcpy.Parameter(name = 'year', displayName = 'year', datatype = 'GPString', parameterType = 'optional', direction = 'input')        parameters = [in_boundary, in_tornado, state, county, year]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        wksp = arcpy.env.workspace = "C:\\Dillon Geiger\\GIS_4085_Python_II\\week5_pythonII\\week5_pythonII.gdb"        in_boundary = parameters[0].valueAsText        in_tornado = parameters[1].valueAsText        state = parameters[2].valueAsText        county = parameters[3].valueAsText        year = parameters[4].valueAsText        # make State selection boundary selection        state_SQL = "STUSPS ='" + state + "'"        state_sel = arcpy.management.SelectLayerByAttribute(            in_boundary, 'NEW_SELECTION', state_SQL)        # make county selection based off state selection and        county_SQL = "NAME ='" + county + "'"        county_sel = arcpy.management.SelectLayerByAttribute(            state_sel, 'SUBSET_SELECTION', county_SQL)        # export as new fc        out_fc = str("{}{}{}".format(county, state, year))        new_fc = arcpy.management.CopyFeatures(county_sel, out_fc)        # make tornado selection based off year        year_SQL = "yr = {}".format(year)        tornado_sel = arcpy.management.SelectLayerByAttribute(            in_tornado, 'NEW_SELECTION', year_SQL)        # make selection of tornado_sel within new fc        tornado_clip = arcpy.analysis.Clip(tornado_sel, new_fc, "Tornado_Clip")        # create new fields in new_fc and populate with clip values        year_field = ["year", 'LONG', "year", "year"]        inj_field = ["total_injuries", 'LONG', "inj_t"]        fatal_field = ["total_fatalities", 'LONG', "fatal_t"]        cost_field = ["total_cost", 'LONG', "cost_t"]        new_fields = arcpy.management.AddFields(            new_fc, [year_field, inj_field, fatal_field, cost_field])        # populate new fields with attribute data from tornado_clip        fields_S = ['yr', 'inj', 'fat', 'loss', 'closs']        inj_list = []        fat_list = []        cost_list = []        with arcpy.da.SearchCursor('Tornado_Clip', fields_S) as cursor:            for row in cursor:                year = row[0]                inj = row[1]                fat = row[2]                cost = row[3] + row[4]                inj_list.append(inj)                fat_list.append(fat)                cost_list.append(cost)        year_cal = arcpy.management.CalculateField(new_fc, 'year', year)        inj_cal = arcpy.management.CalculateField(new_fc, 'inj_t', sum(inj_list))        inj_cal = arcpy.management.CalculateField(new_fc, 'fat_t', sum(fat_list))        inj_cal = arcpy.management.CalculateField(new_fc, 'cost_t', sum(cost_list))        arcpy.management.SelectLayerByAttribute(in_boundary, 'CLEAR_SELECTION')        arcpy.management.SelectLayerByAttribute(in_tornado, 'CLEAR_SELECTION')        print("done")        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return##############################################class PathSelection(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "PathSelection"        self.description = "a user selection of the tornado path based off attribute data"        self.canRunInBackground = False    def getParameterInfo(self):        import arcpy        in_tornado = arcpy.Parameter(name = 'in_tornado', displayName = 'input tornado data', datatype = 'DEFeatureClass', parameterType = 'required', direction = 'input')        state = arcpy.Parameter(name = 'state', displayName = 'state abbreviation', datatype = 'GPString', parameterType = 'required', direction = 'input')        magnitude = arcpy.Parameter(name = 'magnitude', displayName = 'magnitude (EF 0-5)', datatype = 'GPString', parameterType = 'optional', direction = 'input')        path_len_sql = arcpy.Parameter(name = 'path_len_sql', displayName = 'path length SQL (len = miles)', datatype = 'GPSQLExpression', parameterType = 'optional', direction = 'input')        path_len_sql.parameterDependencies = [in_tornado.name]        year_sql = arcpy.Parameter(name = 'year', displayName = 'year', datatype = 'GPSQLExpression', parameterType = 'optional', direction = 'input')        year_sql.parameterDependencies = [in_tornado.name]        date_range_sql = arcpy.Parameter(name = 'date_range_sql', displayName = 'date range', datatype = 'GPSQLExpression', parameterType = 'optional', direction = 'input')        date_range_sql.parameterDependencies = [in_tornado.name]                parameters = [in_tornado, state, magnitude, path_len_sql, year_sql, date_range_sql]        return parameters    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        wksp = arcpy.env.workspace = "C:\\Dillon Geiger\\GIS_4085_Python_II\\week5_pythonII\\week5_pythonII.gdb"                in_tornado = parameters[0].valueAsText        state = parameters[1].valueAsText        magnitude = parameters[2].valueAsText        path_len_sql = parameters[3].valueAsText        #OPTIONAL        year_sql = parameters[4].valueAsText        date_range_sql = parameters[5].valueAsText        # make state selections        state_sql = "st = '{}'".format(state)        state_sel = arcpy.management.SelectLayerByAttribute(in_tornado, 'NEW_SELECTION', state_sql)        statelyr = arcpy.management.CopyFeatures (state_sel, 'state_sel')        # make mag selections        mag_sql = "mag = {}".format(magnitude)        mag_sel = arcpy.management.SelectLayerByAttribute('state_sel', 'SUBSET_SELECTION', mag_sql)        maglyr = arcpy.management.CopyFeatures (mag_sel, 'mag_sel')        # make mag selections        path_len_sel = arcpy.management.SelectLayerByAttribute('mag_sel', 'SUBSET_SELECTION', path_len_sql)        path_len_lyr = arcpy.management.CopyFeatures (path_len_sel, 'path_len_sel')        #make year selection        year_sel = arcpy.management.SelectLayerByAttribute('path_len_sel', 'SUBSET_SELECTION', year_sql)        yearlyr= arcpy.management.CopyFeatures (year_sel, 'year_sel')        #date range selection         date_sel = arcpy.management.SelectLayerByAttribute('path_len_sel', 'SUBSET_SELECTION', date_range_sql)        yearlyr= arcpy.management.CopyFeatures (date_sel, 'date_sel')        return    def postExecute(self, parameters):        """This method takes place after outputs are processed and        added to the display."""        return 